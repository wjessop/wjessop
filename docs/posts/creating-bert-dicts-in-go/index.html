<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		
		<link rel="stylesheet" href="/sass/styles.css">
		<script defer data-domain="willj.net" src="https://plausible.io/js/script.js"></script>

		<link href="https://willj.net/rss.xml" rel="alternate" type="application/rss+xml" title="Will Jessop&#39;s Writings" />

		<title>
			
				Creating BERT dicts in Go
			
		</title>
		<meta
			name="description"
			content="BERT is an interesting data serialisation format, I learn how to create them in Go."
		/>
		<meta name="author" content="Will Jessop">
	</head>
	<body>
		<h1>Will Jessop&#39;s Writings</h1>
		<em></srong><p>Sailing, Food, Programming, Technology, and other things</p></em>
		<nav id="nav" class="nav justify-content-center">
	|

	<a class="nav-link" href="/">Home</a> |

	<a class="nav-link" href="/posts/">Posts</a> |

</nav>


		
	
	
	<time datetime="2013-02-10">Sunday, February 10, 2013</time>
	
	
	|
	
	
	tags:<a href="https://willj.net/tags/go">Go</a> <a href="https://willj.net/tags/programming">programming</a> 
	

	

	

	<hr />

	<h2>Creating BERT dicts in Go</h2>

	<article>
		<p>I’ve been learning Go recently and have written a program to connect to an existing service (written in Ruby) that sends and receives messages serialised as <a href="http://bert-rpc.org/">BERT</a> terms.</p>
<p>I’m posting this partly because I had quite a lot of fun figuring it out and partly to document creating BERT dicts in Go should anyone else need to do this in the future and hit the same issues I did.</p>
<h2 id="why-bert">Why BERT?</h2>
<p>I&rsquo;m a big fan of BERT. It’s compact, flexible, and there are good libs available for serialisation/de-serialisation. So far I’ve exclusively been using the <a href="https://github.com/mojombo/bert">bert gem</a> (written by Tom Preston-Werner, author of the BERT spec).</p>
<h2 id="creating-bert-dicts">Creating BERT dicts</h2>
<p>One of the great features of BERT is the complex types it supports, including dicts. The equivalent to a dict in Ruby would be a hash, in Go a map. They are really simple to create in Ruby:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>require <span style="color:#e6db74">&#39;bert&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">BERT</span><span style="color:#f92672">.</span>encode({<span style="color:#e6db74">&#34;key&#34;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#e6db74">&#34;val&#34;</span>})
</span></span><span style="display:flex;"><span><span style="color:#f92672">=&gt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x83</span><span style="color:#e6db74">h</span><span style="color:#ae81ff">\x03</span><span style="color:#e6db74">d</span><span style="color:#ae81ff">\x00\x04</span><span style="color:#e6db74">bertd</span><span style="color:#ae81ff">\x00\x04</span><span style="color:#e6db74">dictl</span><span style="color:#ae81ff">\x00\x00\x00\x01</span><span style="color:#e6db74">h</span><span style="color:#ae81ff">\x02</span><span style="color:#e6db74">m</span><span style="color:#ae81ff">\x00\x00\x00\x03</span><span style="color:#e6db74">keym</span><span style="color:#ae81ff">\x00\x00\x00\x03</span><span style="color:#e6db74">valj&#34;</span>
</span></span></code></pre></div><p>We can pull this apart and see exactly what the bert gem did to our data. Let&rsquo;s dump the string to an array of 8-bit unsigned integers:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span><span style="color:#66d9ef">BERT</span><span style="color:#f92672">.</span>encode({<span style="color:#e6db74">&#34;key&#34;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#e6db74">&#34;val&#34;</span>})<span style="color:#f92672">.</span>unpack(<span style="color:#e6db74">&#34;C*&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">=&gt;</span> <span style="color:#f92672">[</span><span style="color:#ae81ff">131</span>, <span style="color:#ae81ff">104</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">98</span>, <span style="color:#ae81ff">101</span>, <span style="color:#ae81ff">114</span>, <span style="color:#ae81ff">116</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">105</span>, <span style="color:#ae81ff">99</span>, <span style="color:#ae81ff">116</span>, <span style="color:#ae81ff">108</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">104</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">109</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">107</span>, <span style="color:#ae81ff">101</span>, <span style="color:#ae81ff">121</span>, <span style="color:#ae81ff">109</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">118</span>, <span style="color:#ae81ff">97</span>, <span style="color:#ae81ff">108</span>, <span style="color:#ae81ff">106</span><span style="color:#f92672">]</span>
</span></span></code></pre></div><p>It’s hard to see exactly what happened, but with the BERT docs and the <a href="http://erlang.org/doc/apps/erts/erl_ext_dist.html">erlang External Term Format docs</a> we can see how the hash got encoded.</p>
<pre tabindex="0"><code>magic| tuple |  atom   |       bert     |            |    dict        |  list 1 elem    |      list      |   atom  |      key      |   atom  |      |  val       | nil | nil
131, 104, 3, 100, 0, 4, 98, 101, 114, 116, 100, 0, 4, 100, 105, 99, 116, 108, 0, 0, 0, 1, 108, 0, 0, 0, 2, 100, 0, 3, 107, 101, 121, 100, 0, 3,       118, 97, 108, 106, 106
</code></pre><p>If the formatting of that breakdown is messed up <a href="https://gist.github.com/wjessop/4747914/raw/a7cea5f08b87add27c677145fa49815ed0c98faf/gistfile1.txt">here’s a raw gist</a> that may be clearer.</p>
<p>What you can see here are what the bytes represent (you can see the breakdown of each data type on the External Term Format <a href="http://erlang.org/doc/apps/erts/erl_ext_dist.html">docs</a>). This is great, but why write a blog post just about dicts? Well, they’re easy to create in Ruby:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span><span style="color:#66d9ef">BERT</span><span style="color:#f92672">.</span>encode(<span style="color:#e6db74">:complex</span> <span style="color:#f92672">=&gt;</span> {<span style="color:#e6db74">&#34;key&#34;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">[</span><span style="color:#e6db74">:data</span>, {<span style="color:#e6db74">:structures</span> <span style="color:#f92672">=&gt;</span> <span style="color:#e6db74">&#34;are easy to serialise&#34;</span>}<span style="color:#f92672">]</span>})
</span></span><span style="display:flex;"><span><span style="color:#f92672">=&gt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x83</span><span style="color:#e6db74">h</span><span style="color:#ae81ff">\x03</span><span style="color:#e6db74">d</span><span style="color:#ae81ff">\x00\x04</span><span style="color:#e6db74">bertd</span><span style="color:#ae81ff">\x00\x04</span><span style="color:#e6db74">dictl</span><span style="color:#ae81ff">\x00\x00\x00\x01</span><span style="color:#e6db74">h</span><span style="color:#ae81ff">\x02</span><span style="color:#e6db74">d</span><span style="color:#ae81ff">\x00\a</span><span style="color:#e6db74">complexh</span><span style="color:#ae81ff">\x03</span><span style="color:#e6db74">d</span><span style="color:#ae81ff">\x00\x04</span><span style="color:#e6db74">bertd</span><span style="color:#ae81ff">\x00\x04</span><span style="color:#e6db74">dictl</span><span style="color:#ae81ff">\x00\x00\x00\x01</span><span style="color:#e6db74">h</span><span style="color:#ae81ff">\x02</span><span style="color:#e6db74">m</span><span style="color:#ae81ff">\x00\x00\x00\x03</span><span style="color:#e6db74">keyl</span><span style="color:#ae81ff">\x00\x00\x00\x02</span><span style="color:#e6db74">d</span><span style="color:#ae81ff">\x00\x04</span><span style="color:#e6db74">datah</span><span style="color:#ae81ff">\x03</span><span style="color:#e6db74">d</span><span style="color:#ae81ff">\x00\x04</span><span style="color:#e6db74">bertd</span><span style="color:#ae81ff">\x00\x04</span><span style="color:#e6db74">dictl</span><span style="color:#ae81ff">\x00\x00\x00\x01</span><span style="color:#e6db74">h</span><span style="color:#ae81ff">\x02</span><span style="color:#e6db74">d</span><span style="color:#ae81ff">\x00\n</span><span style="color:#e6db74">structuresm</span><span style="color:#ae81ff">\x00\x00\x00\x15</span><span style="color:#e6db74">are easy to serialisejjjj&#34;</span>
</span></span></code></pre></div><p>but it’s not so obvious in Go, and I hit some issues when trying to create them.</p>
<h2 id="serialising-to-bert-in-golang">Serialising to BERT in Golang</h2>
<p>Serialising data to BERT/BERP in Go is pretty easy for simple cases using the <a href="https://github.com/sethwklein/gobert">gobert</a> lib:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;bytes&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;github.com/sethwklein/gobert&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">buf</span> = new(<span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">bert</span>.<span style="color:#a6e22e">MarshalResponse</span>(<span style="color:#a6e22e">buf</span>, <span style="color:#a6e22e">bert</span>.<span style="color:#a6e22e">Atom</span>(<span style="color:#e6db74">&#34;foo&#34;</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span>(<span style="color:#a6e22e">buf</span>.<span style="color:#a6e22e">Bytes</span>()) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%d &#34;</span>, <span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This gives us:</p>
<pre><code>0 0 0 7 131 100 0 3 102 111 111
</code></pre>
<p>If we run that through the Ruby lib decoder we get:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">BERT</span><span style="color:#f92672">.</span>decode(<span style="color:#f92672">[</span><span style="color:#ae81ff">131</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">102</span>, <span style="color:#ae81ff">111</span>, <span style="color:#ae81ff">111</span><span style="color:#f92672">].</span>pack(<span style="color:#e6db74">&#34;C*&#34;</span>))
</span></span><span style="display:flex;"><span> <span style="color:#f92672">=&gt;</span> <span style="color:#e6db74">:foo</span>
</span></span></code></pre></div><p>(The Ruby bert lib decodes atoms to symbols).</p>
<h2 id="serialising-to-bert-dicts-in-golang">Serialising to BERT dicts in Golang</h2>
<p>However, there is a little more effort involved serialising more complex data structures, in particular dicts, as I found out.</p>
<p>You might have thought that you could just pass in a map:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;bytes&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;github.com/sethwklein/gobert&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">message</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;key1&#34;</span>: <span style="color:#e6db74">&#34;val1&#34;</span>, <span style="color:#e6db74">&#34;key2&#34;</span>: <span style="color:#e6db74">&#34;val2&#34;</span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">buf</span> = new(<span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">bert</span>.<span style="color:#a6e22e">MarshalResponse</span>(<span style="color:#a6e22e">buf</span>, <span style="color:#a6e22e">message</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span>(<span style="color:#a6e22e">buf</span>.<span style="color:#a6e22e">Bytes</span>()) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%d &#34;</span>, <span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We get the output:</p>
<pre><code>0 0 0 1 131
</code></pre>
<p>Well, that doesn’t work. What you end up with is a one byte long BERP. It seems that gobert doesn’t automatically serialise maps. No problem, we’ll build one up manually. A quick look at the BERT documentation shows the format of a dict:</p>
<blockquote>
<p>“Dictionaries (hash tables) are expressed via an array of 2-tuples representing the key/value pairs. The KeysAndValues array is mandatory, such that an empty dict is expressed as {bert, dict, []}. Keys and values may be any term. For example, {bert, dict, [{name, &laquo;“Tom”&raquo;}, {age, 30}]}.”</p>
</blockquote>
<p>So let&rsquo;s create this special structure manually.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;bytes&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;github.com/sethwklein/gobert&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">message1</span> <span style="color:#f92672">:=</span> []<span style="color:#a6e22e">bert</span>.<span style="color:#a6e22e">Term</span>{<span style="color:#a6e22e">bert</span>.<span style="color:#a6e22e">Atom</span>(<span style="color:#e6db74">&#34;key1&#34;</span>), <span style="color:#a6e22e">bert</span>.<span style="color:#a6e22e">Atom</span>(<span style="color:#e6db74">&#34;val1&#34;</span>)}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">message2</span> <span style="color:#f92672">:=</span> []<span style="color:#a6e22e">bert</span>.<span style="color:#a6e22e">Term</span>{<span style="color:#a6e22e">bert</span>.<span style="color:#a6e22e">Atom</span>(<span style="color:#e6db74">&#34;key2&#34;</span>), <span style="color:#a6e22e">bert</span>.<span style="color:#a6e22e">Atom</span>(<span style="color:#e6db74">&#34;val3&#34;</span>)}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">keys_and_values</span> <span style="color:#f92672">:=</span> []<span style="color:#a6e22e">bert</span>.<span style="color:#a6e22e">Term</span>{<span style="color:#a6e22e">message1</span>, <span style="color:#a6e22e">message2</span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dict</span> <span style="color:#f92672">:=</span> []<span style="color:#a6e22e">bert</span>.<span style="color:#a6e22e">Term</span>{<span style="color:#a6e22e">bert</span>.<span style="color:#a6e22e">BertAtom</span>, <span style="color:#a6e22e">bert</span>.<span style="color:#a6e22e">Atom</span>(<span style="color:#e6db74">&#34;dict&#34;</span>), <span style="color:#a6e22e">keys_and_values</span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">buf</span> = new(<span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">bert</span>.<span style="color:#a6e22e">MarshalResponse</span>(<span style="color:#a6e22e">buf</span>, <span style="color:#a6e22e">dict</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span>(<span style="color:#a6e22e">buf</span>.<span style="color:#a6e22e">Bytes</span>()) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%d &#34;</span>, <span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The result:</p>
<pre><code>0 0 0 51 131 104 3 100 0 4 98 101 114 116 100 0 4 100 105 99 116 104 2 104 2 100 0 4 107 101 121 49 100 0 4 118 97 108 49 104 2 100 0 4 107 101 121 50 100 0 4 118 97 108 51
</code></pre>
<p>It looks better, but it doesn’t decode, using Ruby:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">BERT</span><span style="color:#f92672">.</span>decode(<span style="color:#f92672">[</span><span style="color:#ae81ff">131</span>, <span style="color:#ae81ff">104</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">98</span>, <span style="color:#ae81ff">101</span>, <span style="color:#ae81ff">114</span>, <span style="color:#ae81ff">116</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">105</span>, <span style="color:#ae81ff">99</span>, <span style="color:#ae81ff">116</span>, <span style="color:#ae81ff">104</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">104</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">107</span>, <span style="color:#ae81ff">101</span>, <span style="color:#ae81ff">121</span>, <span style="color:#ae81ff">49</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">118</span>, <span style="color:#ae81ff">97</span>, <span style="color:#ae81ff">108</span>, <span style="color:#ae81ff">49</span>, <span style="color:#ae81ff">104</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">107</span>, <span style="color:#ae81ff">101</span>, <span style="color:#ae81ff">121</span>, <span style="color:#ae81ff">50</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">118</span>, <span style="color:#ae81ff">97</span>, <span style="color:#ae81ff">108</span>, <span style="color:#ae81ff">51</span><span style="color:#f92672">].</span>pack(<span style="color:#e6db74">&#34;C*&#34;</span>))
</span></span><span style="display:flex;"><span><span style="color:#e6db74">TypeError</span>: <span style="color:#66d9ef">Invalid</span> dict spec, <span style="color:#f92672">not</span> an erlang list
</span></span></code></pre></div><p>We’re still missing something. Let&rsquo;s compare the output of the Ruby bert lib to the output of gobert for the same data structure:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">BERT</span><span style="color:#f92672">.</span>encode({<span style="color:#e6db74">:key1</span> <span style="color:#f92672">=&gt;</span> <span style="color:#e6db74">:val1</span>, <span style="color:#e6db74">:key2</span> <span style="color:#f92672">=&gt;</span> <span style="color:#e6db74">:val2</span>})<span style="color:#f92672">.</span>unpack(<span style="color:#e6db74">&#34;C*&#34;</span>)
</span></span><span style="display:flex;"><span> <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">[</span><span style="color:#ae81ff">131</span>, <span style="color:#ae81ff">104</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">98</span>, <span style="color:#ae81ff">101</span>, <span style="color:#ae81ff">114</span>, <span style="color:#ae81ff">116</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">105</span>, <span style="color:#ae81ff">99</span>, <span style="color:#ae81ff">116</span>, <span style="color:#ae81ff">108</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">104</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">107</span>, <span style="color:#ae81ff">101</span>, <span style="color:#ae81ff">121</span>, <span style="color:#ae81ff">49</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">118</span>, <span style="color:#ae81ff">97</span>, <span style="color:#ae81ff">108</span>, <span style="color:#ae81ff">49</span>, <span style="color:#ae81ff">104</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">107</span>, <span style="color:#ae81ff">101</span>, <span style="color:#ae81ff">121</span>, <span style="color:#ae81ff">50</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">118</span>, <span style="color:#ae81ff">97</span>, <span style="color:#ae81ff">108</span>, <span style="color:#ae81ff">50</span>, <span style="color:#ae81ff">106</span><span style="color:#f92672">]</span>
</span></span></code></pre></div><p>We’re definitely missing some data in the gobert output.</p>
<p>If you follow along the byte sequences you can see that they start off the same until the 18th byte. In the Ruby output this is ‘108’, or LIST_EXT. In the gobert output it’s 104, a SMALL_TUPLE_EXT. We can see where this difference happens in encode.go in the gobert lib (in the writeTag func):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">case</span> <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">Slice</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">writeSmallTuple</span>(<span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">case</span> <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">Array</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">writeList</span>(<span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">v</span>)
</span></span></code></pre></div><p>Let&rsquo;s decode the BERT data to see where the diversion happens in the underlying data structures:</p>
<pre tabindex="0"><code>magic| tuple  |  atom   |       bert       |   atom   |    dict
  131, 104, 3, 100, 0, 4, 98, 101, 114, 116, 100, 0, 4, 100, 105, 99, 116
</code></pre><p>We can see that the “bert” and “dict” atoms are encoded the same, but the keys_and_values array is getting encoded as a SMALL_TUPLE_EXT by gobert when we wanted a LIST_EXT. If we look back at the gobert code we can see that the decision to use SMALL_TUPLE_EXT over LIST_EXT is dependent on a slice or array being present. We can use the go “reflect” package to look at the arrays/slices we are creating and see what they are:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;reflect&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;github.com/sethwklein/gobert&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">array</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">2</span>]<span style="color:#a6e22e">bert</span>.<span style="color:#a6e22e">Term</span>{}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">slice</span> <span style="color:#f92672">:=</span> []<span style="color:#a6e22e">bert</span>.<span style="color:#a6e22e">Term</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">array_val</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">ValueOf</span>(<span style="color:#a6e22e">array</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">slice_val</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">ValueOf</span>(<span style="color:#a6e22e">slice</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;array is a: %v\n&#34;</span>, <span style="color:#a6e22e">array_val</span>.<span style="color:#a6e22e">Kind</span>())
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;slice is a: %v\n&#34;</span>, <span style="color:#a6e22e">slice_val</span>.<span style="color:#a6e22e">Kind</span>())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre><code>array is a: array
slice is a: slice
</code></pre>
<h2 id="the-fix">The fix</h2>
<p>So, in order to fix our data structure to get gobert to correctly encode the dict we need to change the keys_and_values slice to an array:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;bytes&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;github.com/sethwklein/gobert&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">message1</span> <span style="color:#f92672">:=</span> []<span style="color:#a6e22e">bert</span>.<span style="color:#a6e22e">Term</span>{<span style="color:#a6e22e">bert</span>.<span style="color:#a6e22e">Atom</span>(<span style="color:#e6db74">&#34;key1&#34;</span>), <span style="color:#a6e22e">bert</span>.<span style="color:#a6e22e">Atom</span>(<span style="color:#e6db74">&#34;val1&#34;</span>)}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">message2</span> <span style="color:#f92672">:=</span> []<span style="color:#a6e22e">bert</span>.<span style="color:#a6e22e">Term</span>{<span style="color:#a6e22e">bert</span>.<span style="color:#a6e22e">Atom</span>(<span style="color:#e6db74">&#34;key2&#34;</span>), <span style="color:#a6e22e">bert</span>.<span style="color:#a6e22e">Atom</span>(<span style="color:#e6db74">&#34;val3&#34;</span>)}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">keys_and_values</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">2</span>]<span style="color:#a6e22e">bert</span>.<span style="color:#a6e22e">Term</span>{<span style="color:#a6e22e">message1</span>, <span style="color:#a6e22e">message2</span>} <span style="color:#75715e">// Now an array
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dict</span> <span style="color:#f92672">:=</span> []<span style="color:#a6e22e">bert</span>.<span style="color:#a6e22e">Term</span>{<span style="color:#a6e22e">bert</span>.<span style="color:#a6e22e">BertAtom</span>, <span style="color:#a6e22e">bert</span>.<span style="color:#a6e22e">Atom</span>(<span style="color:#e6db74">&#34;dict&#34;</span>), <span style="color:#a6e22e">keys_and_values</span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">buf</span> = new(<span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">bert</span>.<span style="color:#a6e22e">MarshalResponse</span>(<span style="color:#a6e22e">buf</span>, <span style="color:#a6e22e">dict</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span>(<span style="color:#a6e22e">buf</span>.<span style="color:#a6e22e">Bytes</span>()) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%d &#34;</span>, <span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The result:</p>
<pre><code>0 0 0 55 131 104 3 100 0 4 98 101 114 116 100 0 4 100 105 99 116 108 0 0 0 2 104 2 100 0 4 107 101 121 49 100 0 4 118 97 108 49 104 2 100 0 4 107 101 121 50 100 0 4 118 97 108 51 106
</code></pre>
<p>But more importantly, can we decode the data we encoded?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">BERT</span><span style="color:#f92672">.</span>decode(<span style="color:#f92672">[</span><span style="color:#ae81ff">131</span>, <span style="color:#ae81ff">104</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">98</span>, <span style="color:#ae81ff">101</span>, <span style="color:#ae81ff">114</span>, <span style="color:#ae81ff">116</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">105</span>, <span style="color:#ae81ff">99</span>, <span style="color:#ae81ff">116</span>, <span style="color:#ae81ff">108</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">104</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">107</span>, <span style="color:#ae81ff">101</span>, <span style="color:#ae81ff">121</span>, <span style="color:#ae81ff">49</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">118</span>, <span style="color:#ae81ff">97</span>, <span style="color:#ae81ff">108</span>, <span style="color:#ae81ff">49</span>, <span style="color:#ae81ff">104</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">107</span>, <span style="color:#ae81ff">101</span>, <span style="color:#ae81ff">121</span>, <span style="color:#ae81ff">50</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">118</span>, <span style="color:#ae81ff">97</span>, <span style="color:#ae81ff">108</span>, <span style="color:#ae81ff">51</span>, <span style="color:#ae81ff">106</span><span style="color:#f92672">].</span>pack(<span style="color:#e6db74">&#34;C*&#34;</span>))
</span></span><span style="display:flex;"><span> <span style="color:#f92672">=&gt;</span> {<span style="color:#e6db74">:key1</span><span style="color:#f92672">=&gt;</span><span style="color:#e6db74">:val1</span>, <span style="color:#e6db74">:key2</span><span style="color:#f92672">=&gt;</span><span style="color:#e6db74">:val3</span>}
</span></span></code></pre></div><p>Yes!</p>

	</article>



		<footer>
	<hr>
	<p>You can find me on <a href="https://github.com/wjessop/">Github</a>, <a rel="me" href="https://ruby.social/@wj">Mastodon</a>, <a href="https://twitter.com/will_j">Twitter</a> (now largely abandoned), and <a href="mailto:will@willj.net">Email</a>.</p>
</footer>

	</body>
</html>
